프로그래밍의 두 가지 관점
* 기능
    * 시스템이 외부에 제공하는 행동
    * 개발자의 첫 번째 덕목은 유용한 기능을 버그 없이 구현
* 구조
    * 코드를 어떤 구조로 배치할지를 결정하는 것
    * 나중에 코드를 읽는 개발자가 쉽게 읽을 수 있도록 구현

개발자는 사용자에게 제공할 기능을 버그 없이 구현해야 하고 
다른 개발자가 유지보수할 코드를 수정하기 쉽게 만드는 두 가지 목적을 동시에 달성해야 합니다.

여기서 설계의 가치가 나타납니다.
설계는 어떤 기능을 구현하는데 적합한 코드의 구조를 결정하는 작업
즉, 유지 보수 가능하게 코드를 배치하는 방법을 의미

객체 지향 패러다임을 사용할 경우 기능은 메시지를 주고 받는 객체들 사이의 협력을 통해 구현

기능을 구현하는데 필요한 행동들은 객체들 사이의 책임으로 분배되고
이 객체들이 다른 객체들에게 메시지를 전송하는 방식을 통해 더 큰 책임을 구현

이렇게 결정된 객체들의 협력을 기반으로 코드의 구조를 결정

객체지향 설계 방식은 사용자에게 제공할 기능을 기반으로 객체들의 협력을 설계하고 
객체의 협력 구조를 기반으로 유지보수하기 편리한 코드의 구조를 설계

대표적인 객체지향 설계 방법

* 책임 주도 설계
    * 어플리케이션 기능을 시스템의 책임으로 해석하고
    * 다시 이 시스템의 책임을 협력을 설계하기 위한 문맥으로 설정
    * 그리고 이 문맥 안에서 시스템의 책임을 더 작은 객채의 책임으로 활동하면서 기능 구현에 필요한 객체 사이의 협력을 설계
    * 이렇게 설계된 객체들의 책임과 협력을 코드의 구조를 설계하기 위한 기반으로 활용
    * 클래스 기반 언어에서 런타임의 객체와 협력은 컴파일 타임의 클래스와 관계로 구현할 수 있습니다.
    * 책임 주도 설계에서 가장 중요하면서도 어려운 부분은 책임을 선택하고 책임을 적절한 객체에게 할당하는 방법을 익히는 겁니다.
    * 책임을 할당하는 전통적인 방법 -> 기초편에서 설명

책임을 할당하는 기본적인 가이드를 따르고 많은 경험을 쌓았다고 하더라도 구조를 설계하는 작업은 난해함

설계가 어려운 이유
* 동일한 기능을 구현할 수 있는 구조는 수도 없이 많기 때문
    * 따라서 개발자들은 다양한 설계를 가지고 논쟁을 벌이거나 설득 과정을 거치게 된다.
* 설계가 요구 사항 변경과 관련이 있기 때문이다.
    * 설계가 다른 이유 중에 하나가 개발자마다 요구 사항이 어느 부분에서 바뀔지에 대한 판단이 다르기 때문

각 설계는 그 코드를 설계한 개발자가 가정한 변경을 수용하는데는 최적화 되어 있을지 몰라도 
다른 개발자가 가정한 변경을 수용하기에는 부적합할 수밖에 없습니다.

개발자는 현재 어떤 방식으로 요구사항이 변경되고 있는지를 이해하고
변경에 적합한 설계를 선택해야 합니다.

따라서 좋은 설계를 얻는 가장 좋은 방법은 다양한 변경 방식을 이해하고 각각의 변경에 따라 
적합한 방식으로 객체사이의 책임을 할당하는 방법을 익히는 것

책임 주도 설계에 대해서 많이 오해하고 있는 부분 중 하나가 
책임 주도 설계를 하면 처음부터 모든 변경을 수용할 수 있는
안정적인 구조를 설계할 수 있다고 생각한다는 점입니다

책임 주도 설계는 단지 좀 더 안정적으로 변경할 수 있는 구조를 선택할 수 있도록
책임을 중심에 두는 설계 방법이지 미래를 예측할 수 있는 방법은 아니다

어떤 부분에서 요구 사항이 변경될지를 예측하는 것은 불가능

따라서 현재 시점에서 선택할 수 있는 방법은 가장 단순하게 설계를 선택하고 
실제로 변경이 발생했을 때 변경에 적합한 설계로 개선하는 것

기능은 그대로 두고 변경에 따라 코드를 적절한 구조로 개선 -> 리팩토링

최대한 단순하면서 충분히 유연한 설계를 얻는 방법은 요구 사항이 변경될 때마다 코드를 리팩토링하는 것

이를 위해서는 현재 코드 중에서 어디를 리팩토링할지 그리고 리팩토링한 설계가 단순하면서도
충분히 유연한지를 어떻게 판단할지에 대한 기준이 필요

이럴 때 설계 원칙을 활용할 수 있다.

설계 원칙은 책임주도 설계 방식을 따라 구현한 코드의 품질을 평가할 때 사용

책임 주도 설계를 할 때 설계 원칙을 고려하면 책임의 크기와 협력의 구조를 결정하는데 도움이 된다.

이번 강의에서 다루는 설계 원칙들

* SLAP 단일 추상화 수준 원칙
* SRP 단일 책임 원칙
* OCP 개방 패쇄 원칙
* LSP 리스코프 치환 원칙
* ISP 인터페이스 분리 원칙
* DIP 의존성 역전 원칙
* LoD 디미터 법칙
* TDA 묻지말고 시켜라
* CQS 명령 쿼리 분리 원칙
* DRY 중복하지말라